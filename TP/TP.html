<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Trésor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">

			// ============== IMPORTS ==============
			import * as THREE from '../build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page
			import {OBJLoader} from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import {MTLLoader} from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader
			import { Capsule } from './jsm/math/Capsule.js';
			import { Octree } from './jsm/math/Octree.js';

			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let pointLight, spotLightHelper;
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
			const clock = new THREE.Clock();
			let objCampi;
			const worldOctree = new Octree();
			let playerOnFloor = false;

			// ============== TABLEAUX ===============
			const keyStates = {};

			// ============== PARAMETRES ===============
			const STEPS_PER_FRAME = 5;
			const GRAVITY = 30;

			// ============== APPEL FONCTIONS ==============
			init();
			buildGui();
			animate();

			// =============== EVENT LISTENER ===============
			document.addEventListener( 'keydown', ( event ) => {
				keyStates[ event.code ] = true;
			} );

			document.addEventListener( 'keyup', ( event ) => {
				keyStates[ event.code ] = false;
			} );



			// ============== FONCTIONS ==============
			function init() {

				scene = new THREE.Scene();
				// scene.background = new THREE.Color( 0x000000 );
				scene.background = new THREE.Color( 0x6e7bbb );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );

				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 0.3 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xffffff, 0.5); // (couleur, intensite)
				pointLight.position.set(0, 300, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres
				scene.add(pointLight);


				// ============== IMPORT OBJETS ==============
				// ============== LOADERS =============
				const loaderMTL = new MTLLoader(); // mtl => fichier qui contient les textures d'un objet 3d
				loaderMTL.setPath( 'models/' ); // emplacement des fichiers
				loaderMTL.setMaterialOptions( { side: THREE.DoubleSide } ); // texture appliquer des 2 cotés de l'objet

				// ===== CAVE =====
				// loaderMTL.load('labyCave.mtl', (mtl) => { // new texture d'obj
				// 	const caveOBJ = new OBJLoader(); // new obj
				// 	caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
				// 	caveOBJ.load('models/labyCave.obj', (obj) => { // charge l'objet
				// 		obj.position.set(0,60,0); // x, z, y
				// 		obj.scale.multiplyScalar(100);
				// 		// scene.add( obj ); // ajout de l'obj à la scène
				// 		// worldOctree.fromGraphNode( obj );
				// 	});
				// });

				const loaderGL = new GLTFLoader().setPath( './models/' );
				loaderGL.load( 'labyCave.glb', ( gltf ) => {
					// gltf.scene.scale.multiplyScalar(100);
					gltf.scene.position.set(0,-50,0);
					scene.add( gltf.scene );
					worldOctree.fromGraphNode( gltf.scene );
					// gltf.scene.traverse( function( node ) {
				  //   if( node.material ) {
					// 			node.scale.multiplyScalar(100);
				  //       node.material.side = THREE.DoubleSide;
				  //   }
					// });
					// gltf.scene.traverse( child => {
					// 	if ( child.isMesh ) {
					// 		child.castShadow = true;
					// 		child.receiveShadow = true;
					// 		if ( child.material.map ) {
					// 			child.material.map.anisotropy = 8;
					// 		}
					// 	}
					// } );

					// animate();
				} );

// 				loaderGL.load( 'collision-world.glb', ( gltf ) => {
// 					gltf.scene.rotation.z = 9;
// 					gltf.scene.traverse( function( node ) {
// 				  if( node.material ) {
// 				    node.material.side = THREE.DoubleSide;
// 				  }
// });
// 				scene.add( gltf.scene );
//
// 				worldOctree.fromGraphNode( gltf.scene );

				// gltf.scene.traverse( child => {
				//
				// 	if ( child.isMesh ) {
				//
				// 		child.castShadow = true;
				// 		child.receiveShadow = true;
				//
				// 		if ( child.material.map ) {
				//
				// 			child.material.map.anisotropy = 8;
				//
				// 		}
				//
				// 	}
				//
				// } );
				//
				// animate();

			// } );

				// playerCollider.radius =  1.35;

				// createPerso();

				const geometry = new THREE.BoxGeometry( 5, 5, 5 );
				const material = new THREE.MeshBasicMaterial( { color: 0xFFFFFF } );
				objCampi = new THREE.Mesh( geometry, material );
				objCampi.position.set(0, 100, 0);
				scene.add( objCampi );

				const mesh = new THREE.Mesh(
						new THREE.BoxGeometry( 200, 5, 200 ),
						new THREE.MeshBasicMaterial( { color: 0x363b5c } )
				);
				worldOctree.fromGraphNode( mesh );
				mesh.position.set(0, -60, 0);
				// scene.add( mesh );


				// ============= CAMERA =============
				camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.set(0,120,250);
				camera.lookAt(0, 30, 0); // cordonnées du point regarder par la camera
				controls = new OrbitControls( camera, renderer.domElement ); // Faire bouger la caméra avec la souris
				controls.minDistance = 150; // distance min
				controls.maxDistance = 300; // distance max
				controls.maxPolarAngle = Math.PI / 2.3; // angle max de la caméra

				// ============ EVENT LISTENER ============
				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'keyup', function(e){ // 'keyup' == touche presser
					// if(e.keyCode == 32){ if(animeState == 0){ animeState = 1; } } // si touche espace presser =>    32 == keycode de la touche espace
					if(e.keyCode == 71){ animePerso = 1 } // Si G
				});
			}



			// ============== FONCTIONS UTILES ==============
			// ===== CREATION PERSONNAGE =====
			function createPerso(){
				const angle = [0,90,180,-90];
				const loaderFBX = new FBXLoader();
				loaderFBX.setPath( 'models/' ); // emplacement des fichiers
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if ( child.isMesh ) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					} );
					// obj.getWorldDirection( playerDirection );
					scene.add( obj );
					objCampi = obj;
				});
				console.log('createPerso end');
			}

			// ===== WINDOW REZISE =====
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// ============== GUI ==============
			function buildGui() {
				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Helper: false, // case à cocher => renvoie true OU false
					Freecam: false,
					Intensite: pointLight.intensity,
        	Background: scene.background.getHex(), //getHex() => recup la couleur en hexa
					"Ajouter personnage": function(){ createPerso(); }
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Helper', true, false ).onChange( function( val ) {
					spotLightHelper.visible = val; // defini la visibilite des helpers sur true OU false
					shadowCameraHelper.visible = val;
				});

				gui.add( params, 'Freecam', true, false ).onChange( function( val ) { // permet de désactiver les limites de la camera
					if(val){ // si val == true (donc cocher)
						controls.minDistance = 0;
						controls.maxDistance = 99999999;
						controls.maxPolarAngle = 360;
					} else { // si decocher
						controls.minDistance = 150;
						controls.maxDistance = 300;
						controls.maxPolarAngle = Math.PI / 2.3;
					}
				});

				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	pointLight.intensity = val;
        });

				gui.addColor( params, 'Background' ).onChange( function ( val ) {
        	scene.background = new THREE.Color( val );
        });

				gui.add( params, "Ajouter personnage");

				gui.open(); // Ajout du gui à la scene
			}

			function control( deltaTime ) {
				// gives a bit of air control
				 // * ( playerOnFloor ? 25 : 8 );
				const speedDelta = deltaTime;
				if ( keyStates[ 'KeyW' ] ) {
					playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
				}

				if ( keyStates[ 'KeyS' ] ) {
					playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
				}

				if ( keyStates[ 'KeyA' ] ) {
					playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
				}

				if ( keyStates[ 'KeyD' ] ) {
					playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
				}

				if ( playerOnFloor ) {
					if ( keyStates[ 'Space' ] ) {
						playerVelocity.y = 15;
					}
				}
			}

			function getForwardVector() {
				objCampi.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();

				return playerDirection;
			}

			function getSideVector() {
				objCampi.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( objCampi.up );

				return playerDirection;
			}

			function playerCollisions() {
				const result = worldOctree.capsuleIntersect( playerCollider );
				playerOnFloor = false;
				if ( result ) {
					playerOnFloor = result.normal.y >= 0;
					if ( ! playerOnFloor ) {
						playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
					}
					playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
				}

			}

			function updatePlayer( deltaTime ) {

				let damping = Math.exp( - 4 * deltaTime ) - 1;

				if ( ! playerOnFloor ) {

					playerVelocity.y -= GRAVITY * deltaTime;

					// small air resistance
					damping *= 0.1;
					// console.log(playerVelocity.y);

				}

				playerVelocity.addScaledVector( playerVelocity, damping );

				const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
				playerCollider.translate( deltaPosition );

				playerCollisions();

				objCampi.position.copy( playerCollider.end );

			}

			function teleportPlayerIfOob(){
				if (objCampi.position.y <= -150){
					playerCollider.start.set( 0, -24.5, 0 );
					playerCollider.end.set( 0, -25, 0 );
					playerCollider.radius =  1.35;
					objCampi.position.copy( playerCollider.end );
					// objCampi.rotation.set( 0, 0, 0 );
				}
			}


			function animate() {
				console.log(objCampi.position);
				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;
				window.requestAnimationFrame( animate ); // recup fps
				stats.update();


				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
					control( deltaTime );
					updatePlayer( deltaTime );
				// 	updateSpheres( deltaTime );
					teleportPlayerIfOob();
				//
				}



				renderer.render( scene, camera );
			}
    </script>
  </body>
</html>
