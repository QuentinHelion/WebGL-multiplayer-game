<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Trésor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">

			// ============== IMPORTS ==============
			import * as THREE from '../build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page
			import {OBJLoader} from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import {MTLLoader} from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let pointLight, spotLightHelper;

			// ============== TABLEAUX ===============
			const keyStates = {};

			// ============== PARAMETRES ===============
			const STEPS_PER_FRAME = 30;

			// =============== EVENT LISTENER ===============
			document.addEventListener( 'keydown', ( event ) => {
				keyStates[ event.code ] = true;
			} );

			document.addEventListener( 'keyup', ( event ) => {
				keyStates[ event.code ] = false;
			} );


			// ============== APPEL FONCTIONS ==============
			init();
			buildGui();
			animate();

			// ============== FONCTIONS ==============
			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );

				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 0.3 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xffffff, 0.5); // (couleur, intensite)
				pointLight.position.set(0, 300, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres
				scene.add(pointLight);


				// ============== IMPORT OBJETS ==============
				// ============== LOADERS =============
				const loaderMTL = new MTLLoader(); // mtl => fichier qui contient les textures d'un objet 3d
				loaderMTL.setPath( 'models/' ); // emplacement des fichiers
				loaderMTL.setMaterialOptions( { side: THREE.DoubleSide } ); // texture appliquer des 2 cotés de l'objet

				// ===== CAVE =====
				loaderMTL.load('labyCave.mtl', (mtl) => { // new texture d'obj
					const caveOBJ = new OBJLoader(); // new obj
					caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
					caveOBJ.load('models/labyCave.obj', (obj) => { // charge l'objet
						obj.position.set(0,60,0); // x, z, y
						obj.scale.multiplyScalar(100);
						scene.add(obj); // ajout de l'obj à la scène
					});
				});

				createPerso();




				// ============= CAMERA =============
				camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.set(0,120,250);
				camera.lookAt(0, 30, 0); // cordonnées du point regarder par la camera
				controls = new OrbitControls( camera, renderer.domElement ); // Faire bouger la caméra avec la souris
				controls.minDistance = 150; // distance min
				controls.maxDistance = 300; // distance max
				controls.maxPolarAngle = Math.PI / 2.3; // angle max de la caméra

				// ============ EVENT LISTENER ============
				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'keyup', function(e){ // 'keyup' == touche presser
					if(e.keyCode == 32){ if(animeState == 0){ animeState = 1; } } // si touche espace presser =>    32 == keycode de la touche espace
					if(e.keyCode == 71){ animePerso = 1 } // Si G
				});
			}


			// ============== FONCTIONS UTILES ==============
			// ===== CREATION PERSONNAGE =====
			function createPerso(){
				const angle = [0,90,180,-90];
				const loaderFBX = new FBXLoader();
				loaderFBX.setPath( 'models/' ); // emplacement des fichiers
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if ( child.isMesh ) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					} );
					// obj.position.set(genPos(areaMax, areaMin), 300, genPos(areaMax, areaMin));
					// obj.rotation.y = angle[parseInt(Math.floor(Math.random() * 4))];
					// objArray.push(obj);
					scene.add( obj );
				});
			}

			// ===== WINDOW REZISE =====
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// ============== GUI ==============
			function buildGui() {
				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Helper: false, // case à cocher => renvoie true OU false
					Freecam: false,
					Intensite: pointLight.intensity,
        	Background: scene.background.getHex(), //getHex() => recup la couleur en hexa
					"Ajouter personnage": function(){ createPerso(); }
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Helper', true, false ).onChange( function( val ) {
					spotLightHelper.visible = val; // defini la visibilite des helpers sur true OU false
					shadowCameraHelper.visible = val;
				});

				gui.add( params, 'Freecam', true, false ).onChange( function( val ) { // permet de désactiver les limites de la camera
					if(val){ // si val == true (donc cocher)
						controls.minDistance = 0;
						controls.maxDistance = 99999999;
						controls.maxPolarAngle = 360;
					} else { // si decocher
						controls.minDistance = 150;
						controls.maxDistance = 300;
						controls.maxPolarAngle = Math.PI / 2.3;
					}
				});

				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	pointLight.intensity = val;
        });

				gui.addColor( params, 'Background' ).onChange( function ( val ) {
        	scene.background = new THREE.Color( val );
        });

				gui.add( params, "Ajouter personnage");

				gui.open(); // Ajout du gui à la scene
			}


			function controls( deltaTime ) {

				// gives a bit of air control
				const speedDelta = deltaTime * ( playerOnFloor ? 25 : 8 );
				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;

				if ( keyStates[ 'KeyW' ] ) {
					playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
				}

				if ( keyStates[ 'KeyS' ] ) {
					playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
				}

				if ( keyStates[ 'KeyA' ] ) {
					playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
				}

				if ( keyStates[ 'KeyD' ] ) {
					playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
				}

				if ( playerOnFloor ) {
					if ( keyStates[ 'Space' ] ) {
						playerVelocity.y = 15;
					}
				}
			}


			function animate() {

				window.requestAnimationFrame( animate ); // recup fps
				stats.update();


				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {

					controls( deltaTime );
					updatePlayer( deltaTime );
					updateSpheres( deltaTime );
					teleportPlayerIfOob();

				}



				renderer.render( scene, camera );
			}
    </script>
  </body>
</html>
