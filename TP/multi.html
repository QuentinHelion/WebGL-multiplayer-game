<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Trésor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
    <script src="/socket.io/socket.io.js"></script>
	</head>
	<body>
		<script type="module">

			// ============== IMPORTS ==============
			import * as THREE from '../build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page

      var game;
			document.addEventListener("DOMContentLoaded", function(){ game = new Game(); });

      class Game{
        // this.container;
        this.player;
        // this.cameras;
        this.camera;
        this.scene;
        this.renderer;
        // this.animations = {};
        // this.assetsPath = 'assets/';

        this.remotePlayers = [];
        this.remoteColliders = [];
        this.initialisingPlayers = [];
        this.remoteData = [];

        this.clock = new THREE.Clock();

        init() {

  				this.scene = new THREE.Scene();
  				this.scene.background = new THREE.Color( 0x6e7bbb );

  				// ============= AFFICHAGE STATS =============
  				this.stats = new Stats(); // création stats
  				document.body.appendChild( this.stats.dom ); // ajout des stats a la scene

  				// ============== RENDER ==============
  				this.renderer = new THREE.WebGLRenderer( { antialias: true } );
  				this.renderer.setPixelRatio( window.devicePixelRatio );
  				this.renderer.setSize( window.innerWidth, window.innerHeight );
  				this.renderer.shadowMap.enabled = true; // ombre activer
  				this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
  				document.body.appendChild( this.renderer.domElement );


          this.player = new PlayerLocal(this);
          // player = new THREE.Mesh(
  				// 		new THREE.BoxGeometry( 30, 30, 30 ),
  				// 		new THREE.MeshBasicMaterial( { color: 0xFFFFFF } )
  				// );
  				// player.position.set(0, 0, 0);
  				// scene.add( player );

  				const sol = new THREE.Mesh(
  						new THREE.BoxGeometry( 8000, 5, 8000 ),
  						new THREE.MeshBasicMaterial( { color: 0x363b5c } )
  				);
  				sol.receiveShadow = true;
  				sol.position.set(3500, -60, 3500);
  				scene.add( sol );


  				// ============= CAMERA =============
  				this.camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 1500 );
  				this.camera.position.set(0,120,250);
  				this.camera.lookAt(0, 30, 0); // cordonnées du point regarder par la camera
  				this.controls = new OrbitControls( camera, renderer.domElement ); // Faire bouger la caméra avec la souris
  				this.controls.minDistance = 150; // distance min
  				this.controls.maxDistance = 300; // distance max
  				this.controls.maxPolarAngle = Math.PI / 2.3; // angle max de la caméra

  				// ============ EVENT LISTENER ============
  				window.addEventListener( 'resize', onWindowResize );
          window.addEventListener( 'keydown', ( event ) => {
    				move();
    			} );
  			}

        updateRemotePlayers(dt){
      		if (this.remoteData===undefined || this.remoteData.length == 0 || this.player===undefined || this.player.id===undefined) return;

      		const newPlayers = [];
      		const game = this;
      		//Get all remotePlayers from remoteData array
      		const remotePlayers = [];
      		const remoteColliders = [];

      		this.remoteData.forEach( function(data){
      			if (game.player.id != data.id){
      				//Is this player being initialised?
      				let iplayer;
      				game.initialisingPlayers.forEach( function(player){
      					if (player.id == data.id) iplayer = player;
      				});
      				//If not being initialised check the remotePlayers array
      				if (iplayer===undefined){
      					let rplayer;
      					game.remotePlayers.forEach( function(player){
      						if (player.id == data.id) rplayer = player;
      					});
      					if (rplayer===undefined){
      						//Initialise player
      						game.initialisingPlayers.push( new Player( game, data ));
      					}else{
      						//Player exists
      						remotePlayers.push(rplayer);
      						remoteColliders.push(rplayer.collider);
      					}
      				}
      			}
      		});

      		this.scene.children.forEach( function(object){
      			if (object.userData.remotePlayer && game.getRemotePlayerById(object.userData.id)==undefined){
      				game.scene.remove(object);
      			}
      		});

      		this.remotePlayers = remotePlayers;
      		this.remoteColliders = remoteColliders;
      		this.remotePlayers.forEach(function(player){ player.update( dt ); });
      	}

        getRemotePlayerById(id){
      		if (this.remotePlayers===undefined || this.remotePlayers.length==0) return;

      		const players = this.remotePlayers.filter(function(player){
      			if (player.id == id) return true;
      		});

      		if (players.length==0) return;

      		return players[0];
      	}

        animate() {
      		const game = this;
      		const dt = this.clock.getDelta();

      		requestAnimationFrame( function(){ game.animate(); } );
      		this.updateRemotePlayers(dt);

      		if (this.player.motion !== undefined) this.player.move(dt);

      		if (this.speechBubble!==undefined) this.speechBubble.show(this.camera.position);

      		this.renderer.render( this.scene, this.camera );
      	}
      }

      class Player{
      	constructor(game, options){
      		this.local = true;
      		let model, colour;

      		const colours = ['Black', 'Brown', 'White'];
      		colour = colours[Math.floor(Math.random()*colours.length)];

      		if (options===undefined){
      			const people = ['BeachBabe', 'BusinessMan', 'Doctor', 'FireFighter', 'Housewife', 'Policeman', 'Prostitute', 'Punk', 'RiotCop', 'Roadworker', 'Robber', 'Sheriff', 'Streetman', 'Waitress'];
      			model = people[Math.floor(Math.random()*people.length)];
      		}else if (typeof options =='object'){
      			this.local = false;
      			this.options = options;
      			this.id = options.id;
      			model = options.model;
      			colour = options.colour;
      		}else{
      			model = options;
      		}
      		this.model = model;
      		this.colour = colour;
      		this.game = game;
      		this.animations = this.game.animations;

      		const loader = new THREE.FBXLoader();
      		const player = this;

      		loader.load( `${game.assetsPath}fbx/people/${model}.fbx`, function ( object ) {

      			object.mixer = new THREE.AnimationMixer( object );
      			player.root = object;
      			player.mixer = object.mixer;

      			object.name = "Person";

      			object.traverse( function ( child ) {
      				if ( child.isMesh ) {
      					child.castShadow = true;
      					child.receiveShadow = true;
      				}
      			} );


      			const textureLoader = new THREE.TextureLoader();

      			textureLoader.load(`${game.assetsPath}images/SimplePeople_${model}_${colour}.png`, function(texture){
      				object.traverse( function ( child ) {
      					if ( child.isMesh ){
      						child.material.map = texture;
      					}
      				} );
      			});

      			player.object = new THREE.Object3D();
      			player.object.position.set(3122, 0, -173);
      			player.object.rotation.set(0, 2.6, 0);

      			player.object.add(object);
      			if (player.deleted===undefined) game.scene.add(player.object);

      			if (player.local){
      				game.createCameras();
      				game.sun.target = game.player.object;
      				game.animations.Idle = object.animations[0];
      				if (player.initSocket!==undefined) player.initSocket();
      			}else{
      				const geometry = new THREE.BoxGeometry(100,300,100);
      				const material = new THREE.MeshBasicMaterial({visible:false});
      				const box = new THREE.Mesh(geometry, material);
      				box.name = "Collider";
      				box.position.set(0, 150, 0);
      				player.object.add(box);
      				player.collider = box;
      				player.object.userData.id = player.id;
      				player.object.userData.remotePlayer = true;
      				const players = game.initialisingPlayers.splice(game.initialisingPlayers.indexOf(this), 1);
      				game.remotePlayers.push(players[0]);
      			}

      			if (game.animations.Idle!==undefined) player.action = "Idle";
      		} );
      	}
        //
      	// set action(name){
      	// 	//Make a copy of the clip if this is a remote player
      	// 	if (this.actionName == name) return;
      	// 	const clip = (this.local) ? this.animations[name] : THREE.AnimationClip.parse(THREE.AnimationClip.toJSON(this.animations[name]));
      	// 	const action = this.mixer.clipAction( clip );
        //       action.time = 0;
      	// 	this.mixer.stopAllAction();
      	// 	this.actionName = name;
      	// 	this.actionTime = Date.now();
        //
      	// 	action.fadeIn(0.5);
      	// 	action.play();
      	// }
        //
      	// get action(){
      	// 	return this.actionName;
      	// }

      	// update(dt){
      	// 	this.mixer.update(dt);
        //
      	// 	if (this.game.remoteData.length>0){
      	// 		let found = false;
      	// 		for(let data of this.game.remoteData){
      	// 			if (data.id != this.id) continue;
      	// 			//Found the player
      	// 			this.object.position.set( data.x, data.y, data.z );
      	// 			const euler = new THREE.Euler(data.pb, data.heading, data.pb);
      	// 			this.object.quaternion.setFromEuler( euler );
      	// 			this.action = data.action;
      	// 			found = true;
      	// 		}
      	// 		if (!found) this.game.removePlayer(this);
      	// 	}
      	// }
      }



    </script>
  </body>
</html>
