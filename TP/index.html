<!DOCTYPE html>
<html lang="en">
	<head>
		<head>
			<title>Trésor</title>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
			<link type="text/css" rel="stylesheet" href="main.css">
			<script src="/socket.io/socket.io.js"></script>
		</head>
	</head>
	<body>
		<div id="overlay">
			<button id="startButton" hidden>Play</button>
		</div>
		<script type="module">
			// ============== IMPORTS ==============
			import * as THREE from './build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page

			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OBJLoader } from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import { MTLLoader } from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader
			import { Capsule } from './jsm/math/Capsule.js';
			import { Octree } from './jsm/math/Octree.js';

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let player, player2, playerId,playerShoot, playerShootBuffer, playerTouch, playerTouchBuffer;
			let objChampi;
			let pointLight, pointLight2, spotLightHelper;
			let playerOnFloor = false;
			let sphereIdx = 0;
			let player2Ball;
			let mixer, actionAnime;
			let animeState;
			let gameState = 0;
			let i = 0;

			// ============== VARIABLE OBJECTS ==============
			let obc;
			let obg;
			let cave;

			// ============== CONSTANTES ==============
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
			const clock = new THREE.Clock();
			const socket = io.connect("localhost:2600");
			const worldOctree = new Octree();
			const spheres = [];
			const vector1 = new THREE.Vector3();
			const vector2 = new THREE.Vector3();
			const vector3 = new THREE.Vector3();

			// ============== DEFINITION ==============
			const actionDico = {
				walk: 0,
				jump: 1,
			}

			// ============== TABLEAUX ===============
			const keyStates = {};
			let dataArray = [];
			let playerArray = new Array();

			// ============== PARAMETRES ===============
			const STEPS_PER_FRAME = 5;
			const GRAVITY = 30;
			const NUM_SPHERES = 1;
			const SPHERE_RADIUS = 4;

			// =============== EVENT LISTENER ===============
			document.addEventListener( 'keydown', ( event ) => {
				keyStates[ event.code ] = true;
			});

			document.addEventListener( 'keyup', ( event ) => {
				keyStates[ event.code ] = false;
			});

			document.addEventListener( 'mouseup', () => {
				if(gameState){
					throwBall();
				}
			});

			document.addEventListener( 'mousedown', () => {
				if(gameState){
					document.body.requestPointerLock();
				}
			});

			document.body.addEventListener( 'mousemove', ( event ) => {
				if ( document.pointerLockElement === document.body ) {
					player.rotation.y -= event.movementX / 500;
					player.rotation.x += event.movementY / 500 ;
				}
			});

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {
				sendStartRequest();
			} );

			// ============== APPEL FONCTIONS ==============
			init();
			buildGui();
			animate();


			// ============== FONCTIONS ==============
			function init() {

				// ============= SCENE =============
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x6e7bbb );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );


				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 1 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xffffff, 0.5); // (couleur, intensite)
				pointLight.position.set(0, 100, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres


				pointLight2 = new THREE.PointLight(0xffffff, 0.8); // (couleur, intensite)
				pointLight2.position.set(0, 100, 0); // position (x, z, y)
				pointLight2.castShadow = true; // renvoie des ombres


				const sphereGeometry = new THREE.SphereGeometry( SPHERE_RADIUS, 32, 32 );
				const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0x888855, roughness: 0.8, metalness: 0.5 } );
				for ( let i = 0; i < NUM_SPHERES; i ++ ) {
					const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					sphere.castShadow = true;
					sphere.receiveShadow = true;
					sphere.position.set( 0, 0, 0 );
					scene.add( sphere );
					spheres.push( { mesh: sphere, collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ), velocity: new THREE.Vector3() } );
				}

				const loaderGLB = new GLTFLoader().setPath( 'models/' );
				loaderGLB.load( 'labyCave.gltf', function ( obj ) {
					obj.scene.position.y = -30;
					obj.scene.rotation.z = 6.28;
					obj.scene.scale.multiplyScalar(-1);
					scene.add( obj.scene );
					worldOctree.fromGraphNode( obj.scene );
					cave = obj.scene;
				});

				const sol = new THREE.Mesh(
						new THREE.BoxGeometry( 15000, 5, 15000 ),
						new THREE.MeshPhongMaterial( { color: 0x363b5c, transparent: true, opacity: 0.8  } )
				);
				sol.receiveShadow = true;
				sol.position.set(3500, -50, 3500);
				// scene.add( sol );
				// worldOctree.fromGraphNode( sol );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
				camera.rotation.order = 'YXZ';
				camera.position.y = 15;
				camera.position.z = 2;
				camera.rotation.y = 3.25;


				// ===== CREATION PERSONNAGE =====
				const loaderFBX = new FBXLoader().setPath( 'models/' );

				player = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0 } )
				);
				player.add(camera);
				player.rotation.order = 'YXZ';
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if( child.isMesh ){
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					obj.position.y = camera.position.y - 17;
					player.add( obj );
					player.add(pointLight);
				});
				scene.add(player);

				player2 = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 40, 1 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0 } )
				);
				loaderFBX.load( 'champiAnimate.fbx', function( obj ) {
					obj.traverse( function( child ) {
						if( child.isMesh ){
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					// mixer = new THREE.AnimationMixer( obj );
					// const action = mixer.clipAction( obj.animations[ 1 ] );
					// action.play();
					obj.position.y = player2.position.y - 20;
					obj.add(pointLight2);
					player2.add( obj );
				});

				scene.add(player2);

				socket.emit('init', {
					x: player.position.x,
					y: player.position.y+17,
					z: player.position.z,
					h: player.rotation.y,
					action: actionAnime
				});

				buildChest();

				// ============ EVENT LISTENER ============
				window.addEventListener( 'resize', onWindowResize );
			}

			// ================= FONCTIONS UTILES =================
			// ============== CHEST ==============
			function buildChest(){

				const positionY = -30;
				const positionX = -2300;
				const positionZ = -2065;
				const scaleOBJ = .5;

				// ===== LOADERS =====
				const loader = new THREE.TextureLoader().setPath( 'textures/' );
				const loaderMTL = new MTLLoader().setPath( 'models/' );
				loaderMTL.setMaterialOptions( { side: THREE.DoubleSide } ); // texture appliquer des 2 cotés de l'objet

				// ======== MARCHES ========
				// ===== TEXTURES =====
				const marcheT = [ // texture par face
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}), //MeshPhongMaterial = mesh mat
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierre.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierre.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')})
				];

				// ===== CONE LUMIERE =====
				const coneT = new THREE.MeshBasicMaterial({	color: 0xFFFFFF, opacity: 0.1, transparent: true, side: THREE.DoubleSide});
				const coneGeo = new THREE.ConeGeometry( 70, 350, 60 ); // dimension (radius, hauteur, segments)
				const cone = new THREE.Mesh(coneGeo, coneT); // (dimensions, texture)
				cone.position.set( positionX, positionY+180, positionZ ); // position
				scene.add(cone);

				// ===== OBJECTS =====
				const marcheHeight = 10;
				const marcheA = new THREE.BoxGeometry( 150, marcheHeight, 150 ); // dimensions
				const marcheB = new THREE.BoxGeometry( 100, marcheHeight, 100 );
				const mA = new THREE.Mesh( marcheA, marcheT ); // (dimensions, texture)
				const mB = new THREE.Mesh( marcheB, marcheT );
				mA.position.set(positionX, positionY, positionZ);// position
				mB.position.set(positionX, positionY+marcheHeight, positionZ) // hauteur mA + 10
				mA.receiveShadow = true; // reçoi les ombres
				mB.receiveShadow = true;
				scene.add( mA ); // ajout
				scene.add( mB );
				worldOctree.fromGraphNode( mA );
				worldOctree.fromGraphNode( mB );


				// ===== GEMME =====
				loaderMTL.load('gemme.mtl', (mtl) => { // new texture d'obj
					const gemmeOBJ = new OBJLoader(); // new obj
					gemmeOBJ.setMaterials(mtl); // ajout les texture a l'obj
					gemmeOBJ.load('models/gemme.obj', (obj) => { // charge l'objet
						obj.position.set(positionX,positionY+marcheHeight+15,positionZ); // x, y, z
						obj.traverse( function ( child ) { // Ombres
							if ( child instanceof THREE.Mesh ) { // cree un objet transparent autour l'objet qui prend et renvoie les ombres
								child.receiveShadow = true;
								child.castShadow = true;
							}
						});
						obj.scale.multiplyScalar(scaleOBJ);
						obg = obj; // obliger de mettre l'objet dans une variable externe pour pouvoir l'appeler ensuite dans d'autre fonction
						scene.add(obj); // ajout de l'obj à la scène
						// worldOctree.fromGraphNode( obj );
					});
				});


				// ======== CHEST =======
				// ===== CHEST TOP =====
				loaderMTL.load('chestTop.mtl', (mtl) => { // new texture d'obj
					const chtOBJ = new OBJLoader(); // new obj
					chtOBJ.setMaterials(mtl); // ajout les texture a l'obj
					chtOBJ.load('models/chestTop.obj', (obj) => { // charge l'objet
						obj.position.set(positionX,positionY+marcheHeight+22,positionZ+12.5); // x, z, y
						obj.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								child.receiveShadow = true;
								child.castShadow = true;
							}
						});
						obj.rotation.y = 6.28/2;
						obj.scale.multiplyScalar(scaleOBJ);
						obc = obj;
						scene.add(obj); // ajout de l'obj à la scène
						// worldOctree.fromGraphNode( obj );
					});
				});

				// ===== CHEST BOTTOM =====
				loaderMTL.load('chestBottom.mtl', (mtl) => { // new texture d'obj
					const caveOBJ = new OBJLoader(); // new obj
					caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
					caveOBJ.load('models/chestBottom.obj', (obj) => { // charge l'objet
						obj.position.set(positionX,positionY+marcheHeight+4.5,positionZ); // x, z, y
						obj.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								child.receiveShadow = true;
								child.castShadow = true;
							}
						});
						obj.scale.multiplyScalar(scaleOBJ);
						scene.add(obj); // ajout de l'obj à la scène
						// worldOctree.fromGraphNode( obj );
					});
				});
			}

			function animeChest(){
				if(animeState == 1){ // 1er étape animation (ouvrir le coffre et sortir le gemme)
					if(i >= 100){ // permet de faire tourner x fois le gemme jusqu'à l'arrêt
						animeState = 2; // passe à la 2e étape de l'animation
						i = 0;
					} else {
						obc.rotation.x += 0.03;
						obg.position.y += 0.3;
						obg.rotation.y += 0.05;
						i++;
						// console.log(i);
					}
				} else if(animeState == 2){ // 2e étape animation (refermer le coffre et ranger le gemme)
					if(i >= 100){ // permet de faire tourner x fois le gemme jusqu'à l'arrêt
						animeState = 0;
						i = 0;
					} else {
						obc.rotation.x -= 0.03;
						obg.position.y -= 0.3;
						obg.rotation.y += 0.05;
						i++;
						// console.log(i);
					}
				};
			}

			// ============== WINDOW REZISE ==============
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// ============== GUI ==============
			function buildGui() {
				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Helper: false, // case à cocher => renvoie true OU false
					Freecam: false,
					Intensite: pointLight.intensity,
        	Background: scene.background.getHex(), //getHex() => recup la couleur en hexa
					"Ajouter personnage": function(){ createPerso(); }
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Helper', true, false ).onChange( function( val ) {
					spotLightHelper.visible = val; // defini la visibilite des helpers sur true OU false
					shadowCameraHelper.visible = val;
				});

				gui.add( params, 'Freecam', true, false ).onChange( function( val ) { // permet de désactiver les limites de la camera
					if(val){ // si val == true (donc cocher)
						controls.minDistance = 0;
						controls.maxDistance = 99999999;
						controls.maxPolarAngle = 360;
					} else { // si decocher
						controls.minDistance = 150;
						controls.maxDistance = 300;
						controls.maxPolarAngle = Math.PI / 2.3;
					}
				});

				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	pointLight.intensity = val;
        });

				gui.addColor( params, 'Background' ).onChange( function ( val ) {
        	scene.background = new THREE.Color( val );
        });

				gui.add( params, "Ajouter personnage");

				gui.open(); // Ajout du gui à la scene
			}

			// ============== CONTROLS ==============
			function control( deltaTime ) {
				const speedDelta = deltaTime * ( playerOnFloor ? 350 : 90 );
				// console.log(keyStates);
				if(playerTouchBuffer == undefined && gameState == 1){
					if ( keyStates[ 'KeyW' ] ) {
						if(playerOnFloor){
							actionAnime = 'walk';
						}
						playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
					}

					if ( keyStates[ 'KeyS' ] ) {
						playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
					}

					if ( keyStates[ 'KeyA' ] ) {
						playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
					}

					if ( keyStates[ 'KeyD' ] ) {
						playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
					}

					if ( keyStates[ 'KeyK' ] ) {
						console.log(player.position.x);
						console.log(player.position.z);
					}

					if ( playerOnFloor ) {
						if ( keyStates[ 'Space' ] ) {
							actionAnime = 'jump';
							playerVelocity.y = 70;
						}
					}
					if ( keyStates[ 'KeyQ' ] ) {
						player.rotation.y += 0.03;
					}
					if ( keyStates[ 'KeyE' ] ) {
						player.rotation.y -= 0.03;
					}
				}
			}

			// ============== MOVEMEMENTS ==============
			function getForwardVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();

				return playerDirection;
			}

			function getSideVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( player.up );

				return playerDirection;
			}

			function playerCollisions() {
				const result = worldOctree.capsuleIntersect( playerCollider );
				playerOnFloor = false;
				if ( result ) {
					playerOnFloor = result.normal.y >= 0;
					if ( ! playerOnFloor ) {
						playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
					}
					playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
				}

			}

			function updatePlayer( deltaTime ) {
				let damping = Math.exp( - 4 * deltaTime ) - 1;
				if ( ! playerOnFloor ) {
					playerVelocity.y -= GRAVITY * deltaTime;
					damping *= 0.1;
				}
				playerVelocity.addScaledVector( playerVelocity, damping );
				const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
				playerCollider.translate( deltaPosition );
				playerCollisions();
				player.position.copy( playerCollider.end );
				// updateSocket(player);
			}

			function teleportPlayerIfOob(){
				if (player.position.y <= -150){
					playerCollider.start.set( 0, -24.5, 0 );
					playerCollider.end.set( 0, -25, 0 );
					playerCollider.radius =  1.35;
					player.position.copy( playerCollider.end );
				}
			}

			// ============== BALLES ==============
			function throwBall() {
				const sphere = spheres[ 0 ];
				player.getWorldDirection( playerDirection );
				sphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );
				const impulse = 650 + 30;
				sphere.velocity.copy( playerDirection ).multiplyScalar( impulse );
				sphere.velocity.addScaledVector( playerVelocity, 2 );
				console.log('shot');
				socket.emit('ballShoot', {data: spheres[0].velocity, id: playerId});
			}

			function spheresCollisions() {
				for ( let i = 0, length = spheres.length; i < length; i ++ ) {
					const s1 = spheres[ i ];
					const d3 = s1.collider.center.distanceToSquared( player2.position );
					if(d3 < 90){
						socket.emit('touchPlayer', playerId);
					}
				}
			}

			function updateSpheres( deltaTime ) {
				spheres.forEach( sphere => {
					sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );
					const result = worldOctree.sphereIntersect( sphere.collider );
					if ( result ) {
						sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
						sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );
					} else {
						sphere.velocity.y -= GRAVITY * deltaTime;
					}
					// const damping = Math.exp( - 1.5 * deltaTime ) - 1;
					// sphere.velocity.addScaledVector( sphere.velocity, damping );
					// playerSphereCollision( sphere );
				} );
				spheresCollisions();
				for ( const sphere of spheres ) {
					sphere.mesh.position.copy( sphere.collider.center );
				}
			}


			// ============== FONCTION MULTIJOUEURS ==============
			function remoteData(){
				// console.log("remote !");
				if(dataArray.length > 0){
					for(let data of dataArray){
						if(playerId != data.id){
							player2.position.set(data.x, data.y, data.z );
							player2.rotation.y = data.h;
							if(data.action != actionAnime){
								actionAnime = data.action;
								// mixer = new THREE.AnimationMixer( player2 );
								// console.log( actionAnime );
								// console.log( actionDico[data.action] );
								// const action = mixer.clipAction( player2.animations[ actionDico[data.action] ] );
								// action.play();
							}
						}
					}
				}
			}

			function updateSocket(object){
				// if (this.socket !== undefined){
					//console.log(`PlayerLocal.updateSocket - rotation(${this.object.rotation.x.toFixed(1)},${this.object.rotation.y.toFixed(1)},${this.object.rotation.z.toFixed(1)})`);
					socket.emit('update', {
						x: object.position.x,
						y: object.position.y+17,
						z: object.position.z,
						h: object.rotation.y,
						action: actionAnime
					})
			}

			// ============== DEBUT DE PARTIE ==============
			function sendStartRequest(){
				socket.emit('startRequest');
			}

			function startGame(){
				if(!gameState){
					gameState = 1;
					const overlay = document.getElementById( 'overlay' );
					overlay.remove();
				}
			}

			// ============== FIN DE PARTIE ==============
			function endGame(data){
				animeState = 1;
				if(data === playerId && gameState ){
					console.log("win");
				} else {
					console.log("lose");
				}
				gameState = 0;
			}

			function animate() {
				// ========= LOCAL PART =========

				if( obc && obg && cave && !gameState ){
					document.getElementById('startButton').hidden = false;
				}

				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;
				window.requestAnimationFrame( animate ); // animation de la page
				stats.update();
				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
					control( deltaTime );
					updatePlayer( deltaTime );
					updateSocket( player );
					// updateLight();
					updateSpheres( deltaTime );
					teleportPlayerIfOob();
				}

				// const delta = clock.getDelta();
				// if ( mixer ){
				// 	// for(y = 0; y < mixerArray.length; y++){
				// 		// mixer = mixerArray[y];
				// 		mixer.timeScale = 7;
				// 		mixer.update( delta );
				// 	// }
				// }

				if(player && obg){
					animeChest();
					if(Math.abs(player.position.x - obg.position.x) < 70 && Math.abs(player.position.z - obg.position.z) < 70 ){
						if(!animeState){
							// console.log("win");
							// animeState = 1;
							socket.emit('playerWin',playerId);
						}
					}
				}

				renderer.render( scene, camera );


				// ========= MULTIPLAYER PART =========
				socket.on('setId', function(data){
					playerId = data.id;
				});
				socket.on('remoteData', function(data){
					dataArray = data;
					remoteData();
				});

				socket.on('touchPlayerReponse', function(data){
					if(playerTouchBuffer == undefined && data != playerId){
						playerTouchBuffer = parseInt(clock["oldTime"]);
						console.log('toucher !');
					}
				});

				if(parseInt(clock["oldTime"]) - playerTouchBuffer >= 5000 && playerTouchBuffer){
					playerTouchBuffer = undefined;
				}

				socket.on('end', function(data){
					if(gameState){
						endGame(data);
					}
				});

				socket.on('startGameApprouved', function(){
					console.log('start request approuved');
					startGame();
				});

			}
		</script>
	</body>
</html>
