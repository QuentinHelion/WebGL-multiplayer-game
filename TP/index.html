<!DOCTYPE html>
<html lang="en">
	<head>
		<head>
			<title>Trésor</title>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
			<link type="text/css" rel="stylesheet" href="main.css">
			<script src="/socket.io/socket.io.js"></script>
		</head>
	</head>
	<body>
		<!-- <script src="https://code.jquery.com/jquery-1.11.1.js"></script> -->
		<script type="module">
			// ============== IMPORTS ==============
			import * as THREE from './build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page

			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import {OBJLoader} from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import {MTLLoader} from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader
			import { Capsule } from './jsm/math/Capsule.js';
			import { Octree } from './jsm/math/Octree.js';

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let player, player2, playerId,playerShoot, playerShootBuffer, playerTouch, playerTouchBuffer;
			let objChampi;
			let pointLight, spotLightHelper;
			let playerOnFloor = false;
			let sphereIdx = 0;
			let player2Ball;

			// ============== CONSTANTES ==============
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
			const clock = new THREE.Clock();
			const socket = io.connect("localhost:2600");
			const worldOctree = new Octree();
			const spheres = [];
			const vector1 = new THREE.Vector3();
			const vector2 = new THREE.Vector3();
			const vector3 = new THREE.Vector3();

			// ============== TABLEAUX ===============
			const keyStates = {};
			let dataArray = [];
			let playerArray = new Array();
			// animations = {};

			// ============== PARAMETRES ===============
			const STEPS_PER_FRAME = 5;
			const GRAVITY = 30;
			const NUM_SPHERES = 2;
			const SPHERE_RADIUS = 4;

			// =============== EVENT LISTENER ===============
			document.addEventListener( 'keydown', ( event ) => {
				keyStates[ event.code ] = true;
			} );

			document.addEventListener( 'keyup', ( event ) => {
				keyStates[ event.code ] = false;
			} );

			document.addEventListener( 'mouseup', () => {
				throwBall();
			} );

			document.addEventListener( 'mousedown', () => {
				document.body.requestPointerLock();
			} );

			document.body.addEventListener( 'mousemove', ( event ) => {
				if ( document.pointerLockElement === document.body ) {
					camera.rotation.y -= event.movementX / 500;
					camera.rotation.x -= event.movementY / 500;
				}
			});

			// ============== APPEL FONCTIONS ==============
			init();
			buildGui();
			animate();


			// ============== FONCTIONS ==============
			function init() {

				// ============= SCENE =============
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x6e7bbb );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );


				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 1 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xffffff, 0.5); // (couleur, intensite)
				pointLight.position.set(0, 100, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres
				// scene.add(pointLight);


				const sphereGeometry = new THREE.SphereGeometry( SPHERE_RADIUS, 32, 32 );
				const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0x888855, roughness: 0.8, metalness: 0.5 } );
				for ( let i = 0; i < NUM_SPHERES; i ++ ) {
					const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					sphere.castShadow = true;
					sphere.receiveShadow = true;
					sphere.position.set( 0, 0, 0 );
					scene.add( sphere );
					spheres.push( { mesh: sphere, collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ), velocity: new THREE.Vector3() } );
				}

				// player2Ball = new THREE.Mesh( sphereGeometry, sphereMaterial );
				// player2Ball.castShadow = true;
				// player2Ball.receiveShadow = true;
				// scene.add( player2Ball );

				const loaderGLB = new GLTFLoader().setPath( 'models/' );
				loaderGLB.load( 'labyCave.gltf', function ( obj ) {
					obj.scene.position.y = -20;
					obj.scene.rotation.z = 6.28;
					obj.scene.scale.multiplyScalar(-1);
					scene.add( obj.scene );
					worldOctree.fromGraphNode( obj.scene );
				});

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
				camera.rotation.order = 'YXZ';

				createPerso();
				createPerso2();

				player = new THREE.Mesh(
					new THREE.BoxGeometry( 5, 5, 5 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF } )
				);

				player2 = playerArray[1];
				player2 = new THREE.Mesh(
					new THREE.BoxGeometry( 5, 5, 5 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF } )
				);

				console.log( spheres[0].velocity );
				socket.emit('init', {
					// model: model,
					// colour: this.colour,
					x: player.position.x,
					y: player.position.y,
					z: player.position.z,
					h: player.rotation.y,
					// b: spheres[0].velocity,
					// bx: spheres[0].velocity.x,
					// by: spheres[0].velocity.y,
					// bz: spheres[0].velocity.z
					// pb: this.object.rotation.x
				});

				// ============ EVENT LISTENER ============
				window.addEventListener( 'resize', onWindowResize );
			}

			// ================= FONCTIONS UTILES =================
			// ============== WINDOW REZISE ==============
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// ===== CREATION PERSONNAGE =====
			function createPerso(){
				const loaderFBX = new FBXLoader();
				loaderFBX.setPath( 'models/' ); // emplacement des fichiers
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if ( child.isMesh ) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					} );
					// obj.rotation.y = 180;
					obj.position.x = camera.position.x;
					obj.position.y  = camera.position.y + 40;
					obj.position.z = camera.position.z;
					camera.rotation.y = 180;
					// obj.getWorldDirection( playerDirection );
					// obj.position.set(0, 100, 0);
					// obj.add(pointLight);
					camera.add( obj );
					// scene.add( obj );
					// return obj;/
					player = camera;
					// playerArray.push(obj);
				});
				console.log('createPerso end');
			}

			function createPerso2(){
				const loaderFBX = new FBXLoader();
				loaderFBX.setPath( 'models/' ); // emplacement des fichiers
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if ( child.isMesh ) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					} );
					// obj.getWorldDirection( playerDirection );
					// obj.position.set(0, 100, 0);
					obj.add(pointLight);
					scene.add( obj );
					// return obj;/
					player2 = obj;
					// playerArray.push(obj);
				});
				console.log('createPerso end');
			}

			// ============== GUI ==============
			function buildGui() {
				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Helper: false, // case à cocher => renvoie true OU false
					Freecam: false,
					Intensite: pointLight.intensity,
        	Background: scene.background.getHex(), //getHex() => recup la couleur en hexa
					"Ajouter personnage": function(){ createPerso(); }
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Helper', true, false ).onChange( function( val ) {
					spotLightHelper.visible = val; // defini la visibilite des helpers sur true OU false
					shadowCameraHelper.visible = val;
				});

				gui.add( params, 'Freecam', true, false ).onChange( function( val ) { // permet de désactiver les limites de la camera
					if(val){ // si val == true (donc cocher)
						controls.minDistance = 0;
						controls.maxDistance = 99999999;
						controls.maxPolarAngle = 360;
					} else { // si decocher
						controls.minDistance = 150;
						controls.maxDistance = 300;
						controls.maxPolarAngle = Math.PI / 2.3;
					}
				});

				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	pointLight.intensity = val;
        });

				gui.addColor( params, 'Background' ).onChange( function ( val ) {
        	scene.background = new THREE.Color( val );
        });

				gui.add( params, "Ajouter personnage");

				gui.open(); // Ajout du gui à la scene
			}

			// ============== CONTROLS ==============
			function control( deltaTime ) {
				const speedDelta = deltaTime * ( playerOnFloor ? 350 : 90 );
				// console.log(keyStates);
				if(!playerTouch){
					if ( keyStates[ 'KeyW' ] ) {
						playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
					}

					if ( keyStates[ 'KeyS' ] ) {
						playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
					}

					if ( keyStates[ 'KeyA' ] ) {
						playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
					}

					if ( keyStates[ 'KeyD' ] ) {
						playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
					}

					if ( playerOnFloor ) {
						if ( keyStates[ 'Space' ] ) {
							playerVelocity.y = 70;
						}
					}
					if ( keyStates[ 'KeyQ' ] ) {
						player.rotation.y += 0.03;
					}
					if ( keyStates[ 'KeyE' ] ) {
						player.rotation.y -= 0.03;
					}
				}
			}

			// ============== MOVEMEMENT ==============
			function getForwardVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();

				return playerDirection;
			}

			function getSideVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( player.up );

				return playerDirection;
			}

			function playerCollisions() {
				const result = worldOctree.capsuleIntersect( playerCollider );
				playerOnFloor = false;
				if ( result ) {
					playerOnFloor = result.normal.y >= 0;
					if ( ! playerOnFloor ) {
						playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
					}
					playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
				}

			}

			function updatePlayer( deltaTime ) {
				let damping = Math.exp( - 4 * deltaTime ) - 1;
				if ( ! playerOnFloor ) {
					playerVelocity.y -= GRAVITY * deltaTime;
					damping *= 0.1;
				}
				playerVelocity.addScaledVector( playerVelocity, damping );
				const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
				playerCollider.translate( deltaPosition );
				playerCollisions();
				player.position.copy( playerCollider.end );
				// updateSocket(player);
			}

			function teleportPlayerIfOob(){
				if (player.position.y <= -150){
					playerCollider.start.set( 0, -24.5, 0 );
					playerCollider.end.set( 0, -25, 0 );
					playerCollider.radius =  1.35;
					player.position.copy( playerCollider.end );
				}
			}

			function throwBall() {
				const sphere = spheres[ 0 ];
				player.getWorldDirection( playerDirection );
				sphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );
				const impulse = 150 + 30;// * ( 1 - Math.exp( ( mouseTime - performance.now() ) * 0.001 ) );
				sphere.velocity.copy( playerDirection ).multiplyScalar( impulse );
				sphere.velocity.addScaledVector( playerVelocity, 2 );
				// sphereIdx = ( sphereIdx + 1 ) % spheres.length;
				console.log('shot');
				socket.emit('ballShoot', {data: spheres[0].velocity, id: playerId});
			}


			// function playerSphereCollision( sphere ) {
			// 	const center = vector1.addVectors( playerCollider.start, playerCollider.end ).multiplyScalar( 0.5 );
			// 	const sphere_center = sphere.collider.center;
			// 	const r = playerCollider.radius + sphere.collider.radius;
			// 	const r2 = r * r;
			// 	// approximation: player = 3 spheres
			// 	for ( const point of [ playerCollider.start, playerCollider.end, center ] ) {
			// 		const d2 = point.distanceToSquared( sphere_center );
			// 		if ( d2 < r2 ) {
			// 			const normal = vector1.subVectors( point, sphere_center ).normalize();
			// 			const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( playerVelocity ) );
			// 			const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );
			// 			playerVelocity.add( v2 ).sub( v1 );
			// 			sphere.velocity.add( v1 ).sub( v2 );
			// 			const d = ( r - Math.sqrt( d2 ) ) / 2;
			// 			sphere_center.addScaledVector( normal, - d );
			// 		}
			// 	}
			// }

			function spheresCollisions() {
				for ( let i = 0, length = spheres.length; i < length; i ++ ) {
					const s1 = spheres[ i ];
				// 	for ( let j = i + 1; j < length; j ++ ) {
				// 		const s2 = spheres[ j ];
				// 		const d2 = s1.collider.center.distanceToSquared( s2.collider.center );
				// 		const r = s1.collider.radius + s2.collider.radius;
				// 		const r2 = r * r;
				// 		if ( d2 < r2 ) {
				// 			const normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();
				// 			const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );
				// 			const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );
				// 			s1.velocity.add( v2 ).sub( v1 );
				// 			s2.velocity.add( v1 ).sub( v2 );
				// 			const d = ( r - Math.sqrt( d2 ) ) / 2;
				// 			s1.collider.center.addScaledVector( normal, d );
				// 			s2.collider.center.addScaledVector( normal, - d );
				// 		}
				// 	}
					const d3 = s1.collider.center.distanceToSquared( player2.position );
					if(d3 < 70){
						playerShoot = true;
					} else {
						playerShoot = false;
					}

				}
			}

			function updateSpheres( deltaTime ) {
				spheres.forEach( sphere => {
					sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );
					const result = worldOctree.sphereIntersect( sphere.collider );
					if ( result ) {
						sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
						sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );
					} else {
						sphere.velocity.y -= GRAVITY * deltaTime;
					}
					// const damping = Math.exp( - 1.5 * deltaTime ) - 1;
					// sphere.velocity.addScaledVector( sphere.velocity, damping );
					// playerSphereCollision( sphere );
				} );
				spheresCollisions();
				for ( const sphere of spheres ) {
					sphere.mesh.position.copy( sphere.collider.center );
				}
				// updateSocket(player);
			}



			// ============== FONCTION MULTIJOUEURS ==============
			function remoteData(){
				// console.log("remote !");
				if(dataArray.length > 0){
					for(let data of dataArray){
						if(playerId != data.id){
							player2.position.set(data.x, data.y, data.z );
							player2.rotation.y = data.h;

							// player2Ball.position.set(data.b)
							// spheres[1].velocity.x =  data.bx;
							// spheres[1].velocity.y =  data.by;
							// spheres[1].velocity.z =  data.bz;

							// console.log(spheres[1].velocity);

							// console.log(data.b);
						}
						// if(playerId == data.id && data.touch && !playerShootBuffer){
						// 	console.log("bloquer");
						// 	playerShoot = true;
						// 	playerShootBuffer = parseInt(clock["oldTime"]);
						// }
					}
				}
			}

			function updateSocket(object){
				// if (this.socket !== undefined){
					//console.log(`PlayerLocal.updateSocket - rotation(${this.object.rotation.x.toFixed(1)},${this.object.rotation.y.toFixed(1)},${this.object.rotation.z.toFixed(1)})`);
					socket.emit('update', {
						x: object.position.x,
						y: object.position.y,
						z: object.position.z,
						h: object.rotation.y,
						// b: spheres[0].velocity,
						// bx: spheres[0].velocity.x,
						// by: spheres[0].velocity.y,
						// bz: spheres[0].velocity.z
						// pb: this.object.rotation.x,
						// action: this.action
					})
					// console.log(spheres[0].velocity.y);
				// }
			}

			function animate() {
				// ========= LOCAL PART =========
				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;
				window.requestAnimationFrame( animate ); // animation de la page
				stats.update();
				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
					control( deltaTime );
					updatePlayer( deltaTime );
					updateSocket( player );
					// updateLight();
					updateSpheres( deltaTime );
					teleportPlayerIfOob();
				}

				renderer.render( scene, camera );


				// ========= MULTIPLAYER PART =========
				socket.on('setId', function(data){
					playerId = data.id;
					// console.log( data.id );
				});
				socket.on('remoteData', function(data){
					dataArray = data;
					remoteData();
				});

				if(playerShoot != playerShootBuffer){
					// playerShootBuffer = playerShoot;
					if(playerShoot){
						console.log('touch');
						socket.emit('touchPlayer', playerId);
					}
				}

				socket.on('touchPlayer', function(data){
					playerTouch = true;
					playerTouchBuffer = parseInt(clock["oldTime"]);
					// console.log('t')
				});

				if(parseInt(clock["oldTime"]) - playerTouchBuffer >= 5000 && playerTouchBuffer){
					playerTouch = false;
					playerTouchBuffer = undefined;
				}

				socket.on('ballShoot', function(data){
					spheres[1].velocity.copy(data);
					// console.log(spheres[1].velocity);
				});


				// console.log(spheres[0].position);




				// socket.on('userData', function(userData){
				// 	// console.log(userData.x);
				// 	// player.position.set(userData.x, userData.y,userData.z);
				// });

			}
		</script>
	</body>
</html>
