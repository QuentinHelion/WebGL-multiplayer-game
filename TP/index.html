<!DOCTYPE html>
<html lang="en">
	<head>
		<head>
			<title>Trésor</title>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
			<link type="text/css" rel="stylesheet" href="main.css">
			<script src="/socket.io/socket.io.js"></script>
		</head>
	</head>
	<body>
		<div id="overlay">
			<video  class="video-fluid z-depth-1" id="overlay" autoplay loop  muted>
				<source src="media/Cave.mp4" type="video/mp4" />
			</video>
			<div id="under-overlay">
				<h1 id="countdown"></h1>
				<h1 id="overlay">Welcome to the MushroomCave</h1>
				<button id="startButton" type="button" hidden>Lancer la partie</button>
			</div>
			<p id="overlay">Presented by Khadda Hicham, Siad Racha, Hélion Quentin</p>
		</div>
		<h1 id="message" hidden></h1>

		<!-- ============== AUDIOS ============== -->
		<audio id="chest" preload="auto" autoplay hidden loop>
			<source src="media/chest.mp3" type="audio/mpeg">
		</audio>
		<audio id="goute" preload="auto" autoplay hidden loop>
			<source src="media/goute.mp3" type="audio/mpeg">
		</audio>
		<audio id="goute2" preload="auto" autoplay hidden loop>
			<source src="media/goute.mp3" type="audio/mpeg">
		</audio>
		<audio id="goute3" preload="auto" autoplay hidden loop>
			<source src="media/goute.mp3" type="audio/mpeg">
		</audio>
		<audio id="caverne" preload="auto" autoplay hidden loop>
			<source src="media/caverne.mp3" type="audio/mpeg">
		</audio>
		<audio id="caverne2" preload="auto" autoplay hidden loop>
			<source src="media/caverne.mp3" type="audio/mpeg">
		</audio>
		<audio id="caverne3" preload="auto" autoplay hidden loop>
			<source src="media/caverne.mp3" type="audio/mpeg">
		</audio>


		<script type="module">
			// ============== IMPORTS ==============
			import * as THREE from './build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page

			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OBJLoader } from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import { MTLLoader } from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader
			import { Capsule } from './jsm/math/Capsule.js';
			import { Octree } from './jsm/math/Octree.js';

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let player, player2, playerId,playerShoot, playerShootBuffer, playerTouch, playerTouchBuffer;
			let objChampi;
			let pointLight, pointLight2, spotLightHelper;
			let playerOnFloor = false;
			let sphereIdx = 0;
			let player2Ball;
			let mixer, actionAnime;
			let animeState;
			let startClockBuffer;
			let gameState = 0; // 0 => non, 1 => jeu en cours, 2 => fin
			let i = 0;
			let actionAnimeBuffer;
			let intensiter = 1;
			let listener,soundaa,audioLoad;
			let soundVolume = 5;

			// ============== VARIABLE OBJECTS ==============
			let obc;
			let obg;
			let cave;

			// ============== CONSTANTES ==============
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
			const clock = new THREE.Clock();
			const socket = io.connect("localhost:2600");
			const worldOctree = new Octree();
			const spheres = [];
			const vector1 = new THREE.Vector3();
			const vector2 = new THREE.Vector3();
			const vector3 = new THREE.Vector3();

			// ============== DEFINITION ==============
			const actions = [
				"champiWalk.fbx",
				"champiJump.fbx",
				"champiRight.fbx",
				"champiLeft.fbx",
				"champiBack.fbx",
				"champiFall.fbx",
				"champiStand.fbx",
			];

			const actionDicoNbr = {
				walk:  0,
				jump:  1,
				right: 2,
				left:  3,
				back:  4,
				fall:  5,
				stand: 6,
			};

			// ============== TABLEAUX ===============
			const keyStates = {};
			let dataArray = [];
			let playerArray = new Array();
			let actionArray = new Array();
			let audioArray = new Array();

			// ============== PARAMETRES ===============
			const STEPS_PER_FRAME = 5;
			const GRAVITY = 30;
			const NUM_SPHERES = 1;
			const SPHERE_RADIUS = 4;

			// =============== EVENT LISTENER ===============
			document.addEventListener( 'keydown', ( event ) => {
				keyStates[ event.code ] = true;
			});

			document.addEventListener( 'keyup', ( event ) => {
				keyStates[ event.code ] = false;
			});

			document.addEventListener( 'mouseup', () => {
				if(gameState){
					throwBall();
				}
			});

			document.addEventListener( 'mousedown', () => {
				if(gameState){
					document.body.requestPointerLock();
				}
			});

			document.body.addEventListener( 'mousemove', ( event ) => {
				if ( document.pointerLockElement === document.body ) {
					player.rotation.y -= event.movementX / 500;
					player.rotation.x += event.movementY / 500 ;
				}
			});

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {
				sendStartRequest();
			} );

			// ============== APPEL FONCTIONS ==============
			init();
			buildGui();
			animate();


			// ============== FONCTIONS ==============
			function init() {

				// ============= SCENE =============
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x6e7bbb );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );


				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 1 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xD07D22, 0.2); // (couleur, intensite)
				pointLight.position.set(0, 100, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres


				pointLight2 = new THREE.PointLight(0xD07D22, 0.8); // (couleur, intensite)
				pointLight2.position.set(0, 100, 0); // position (x, z, y)
				pointLight2.castShadow = true; // renvoie des ombres


				const sphereGeometry = new THREE.SphereGeometry( SPHERE_RADIUS, 32, 32 );
				const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0x888855, roughness: 0.8, metalness: 0.5 } );
				for ( let i = 0; i < NUM_SPHERES; i ++ ) {
					const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					sphere.castShadow = true;
					sphere.receiveShadow = true;
					sphere.position.set( 0, 0, 0 );
					scene.add( sphere );
					spheres.push( { mesh: sphere, collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ), velocity: new THREE.Vector3() } );
				}

				const loaderGLB = new GLTFLoader().setPath( 'models/' );
				loaderGLB.load( 'labyCave.gltf', function ( obj ) {
					obj.scene.position.y = -30;
					obj.scene.rotation.z = 6.28;
					obj.scene.scale.multiplyScalar(-1);
					scene.add( obj.scene );
					// worldOctree.fromGraphNode( obj.scene );
					cave = obj.scene;
				});

				const sol = new THREE.Mesh(
						new THREE.BoxGeometry( 15000, 5, 15000 ),
						new THREE.MeshPhongMaterial( { color: 0x363b5c, transparent: true, opacity: 0.8  } )
				);
				sol.receiveShadow = true;
				sol.position.set(3500, -50, 3500);
				scene.add( sol );
				worldOctree.fromGraphNode( sol );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
				camera.rotation.order = 'YXZ';
				camera.position.y = 15;
				camera.position.z = 2;
				camera.rotation.y = 3.25;


				// ===== CREATION PERSONNAGE =====
				const loaderFBX = new FBXLoader().setPath( 'models/' );

				player = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0 } )
				);
				player.add(camera);
				player.rotation.order = 'YXZ';
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if( child.isMesh ){
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					obj.position.y = camera.position.y - 17;
					player.add( obj );
					player.add(pointLight);
				});
				scene.add(player);

				player2 = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 40, 1 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0 } )
				);
				loaderFBX.load( 'champi.fbx', function( obj ) {
					obj.traverse( function( child ) {
						if( child.isMesh ){
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					obj.rotation.y = 3.25;
					obj.position.y = player2.position.y - 20;
					obj.add(pointLight2);
					player2.add( obj );
				});

				scene.add(player2);

				socket.emit('init', {
					x: player.position.x,
					y: player.position.y+17,
					z: player.position.z,
					h: player.rotation.y,
					action: actionAnime
				});


				// ======= LOAD ANIMATION =======
				for(let x = 0; x < actions.length; x++){
					loaderFBX.load(actions[x], function (obj) {
						actionArray.push(obj.animations[ 0 ]);
					});
				}

				// ======= AUDIO =======
				listener = new THREE.AudioListener();
				scene.add(listener);
				soundaa = new THREE.Audio( listener );
				audioLoad = new THREE.AudioLoader().setPath('./media/');


				buildChest();

				// ============ EVENT LISTENER ============
				window.addEventListener( 'resize', onWindowResize );
			}

			// ================= FONCTIONS UTILES =================
			// ============== SPATIAL SOUND ==============
			function buildSound(sound, posX, posZ){
				const posY = -10;
				const mesh = new THREE.Mesh(
					new THREE.SphereGeometry( 1.9, 20, 20 ),
					new THREE.MeshPhongMaterial( { color: 0xffffff,opacity: 1, transparent: true } )
				);
				mesh.position.set(posX, posY, posZ);
				const posAudio = new THREE.PositionalAudio( listener );
				const songElement = document.getElementById( sound );
				posAudio.setMediaElementSource( songElement );
				posAudio.setRefDistance( .1 );
				posAudio.setVolume( soundVolume );
				songElement.play();
				audioArray.push( posAudio );
				mesh.add(posAudio);
				scene.add(mesh);
			}

			// ============== LOAD SOUND ==============
			function loadSound(){
				buildSound("chest",-2300,-2065);
				buildSound("caverne",0,0);
				buildSound("caverne2",-736,-2200);
				buildSound("caverne3",-2280,-931);
				buildSound("goute",-40,-1470);
				buildSound("goute2",-1540,-430);
				buildSound("goute3",-1272,-1180);
			}

			// ============== CHEST ==============
			function buildChest(){

				const positionY = -30;
				const positionX = -2300;
				const positionZ = -2065;
				const scaleOBJ = .5;

				// ===== LOADERS =====
				const loader = new THREE.TextureLoader().setPath( 'textures/' );
				const loaderMTL = new MTLLoader().setPath( 'models/' );
				loaderMTL.setMaterialOptions( { side: THREE.DoubleSide } ); // texture appliquer des 2 cotés de l'objet

				// ======== MARCHES ========
				// ===== TEXTURES =====
				const marcheT = [ // texture par face
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}), //MeshPhongMaterial = mesh mat
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierre.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierre.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')}),
					new THREE.MeshPhongMaterial({map: loader.load('dallePierreCoter.jpg')})
				];

				// ===== CONE LUMIERE =====
				const coneT = new THREE.MeshBasicMaterial({	color: 0xFFFFFF, opacity: 0.1, transparent: true, side: THREE.DoubleSide});
				const coneGeo = new THREE.ConeGeometry( 70, 350, 60 ); // dimension (radius, hauteur, segments)
				const cone = new THREE.Mesh(coneGeo, coneT); // (dimensions, texture)
				cone.position.set( positionX, positionY+180, positionZ ); // position
				scene.add(cone);

				// ===== OBJECTS =====
				const marcheHeight = 10;
				const marcheA = new THREE.BoxGeometry( 150, marcheHeight, 150 ); // dimensions
				const marcheB = new THREE.BoxGeometry( 100, marcheHeight, 100 );
				const mA = new THREE.Mesh( marcheA, marcheT ); // (dimensions, texture)
				const mB = new THREE.Mesh( marcheB, marcheT );
				mA.position.set(positionX, positionY, positionZ);// position
				mB.position.set(positionX, positionY+marcheHeight, positionZ) // hauteur mA + 10
				mA.receiveShadow = true; // reçoi les ombres
				mB.receiveShadow = true;
				scene.add( mA ); // ajout
				scene.add( mB );
				worldOctree.fromGraphNode( mA );
				worldOctree.fromGraphNode( mB );


				// ===== GEMME =====
				loaderMTL.load('gemme.mtl', (mtl) => { // new texture d'obj
					const gemmeOBJ = new OBJLoader(); // new obj
					gemmeOBJ.setMaterials(mtl); // ajout les texture a l'obj
					gemmeOBJ.load('models/gemme.obj', (obj) => { // charge l'objet
						obj.position.set(positionX,positionY+marcheHeight+15,positionZ); // x, y, z
						obj.traverse( function ( child ) { // Ombres
							if ( child instanceof THREE.Mesh ) { // cree un objet transparent autour l'objet qui prend et renvoie les ombres
								child.receiveShadow = true;
								child.castShadow = true;
							}
						});
						obj.scale.multiplyScalar(scaleOBJ);
						obg = obj; // obliger de mettre l'objet dans une variable externe pour pouvoir l'appeler ensuite dans d'autre fonction
						scene.add(obj); // ajout de l'obj à la scène
						// worldOctree.fromGraphNode( obj );
					});
				});


				// ======== CHEST =======
				// ===== CHEST TOP =====
				loaderMTL.load('chestTop.mtl', (mtl) => { // new texture d'obj
					const chtOBJ = new OBJLoader(); // new obj
					chtOBJ.setMaterials(mtl); // ajout les texture a l'obj
					chtOBJ.load('models/chestTop.obj', (obj) => { // charge l'objet
						obj.position.set(positionX,positionY+marcheHeight+22,positionZ+12.5); // x, z, y
						obj.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								child.receiveShadow = true;
								child.castShadow = true;
							}
						});
						obj.rotation.y = 6.28/2;
						obj.scale.multiplyScalar(scaleOBJ);
						obc = obj;
						scene.add(obj); // ajout de l'obj à la scène
						// worldOctree.fromGraphNode( obj );
					});
				});

				// ===== CHEST BOTTOM =====
				loaderMTL.load('chestBottom.mtl', (mtl) => { // new texture d'obj
					const caveOBJ = new OBJLoader(); // new obj
					caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
					caveOBJ.load('models/chestBottom.obj', (obj) => { // charge l'objet
						obj.position.set(positionX,positionY+marcheHeight+4.5,positionZ); // x, z, y
						obj.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								child.receiveShadow = true;
								child.castShadow = true;
							}
						});
						obj.scale.multiplyScalar(scaleOBJ);
						scene.add(obj); // ajout de l'obj à la scène
						// worldOctree.fromGraphNode( obj );
					});
				});
			}

			function animeChest(){
				if(animeState == 1){ // 1er étape animation (ouvrir le coffre et sortir le gemme)
					if(i >= 100){ // permet de faire tourner x fois le gemme jusqu'à l'arrêt
						animeState = 2; // passe à la 2e étape de l'animation
						i = 0;
					} else {
						obc.rotation.x += 0.03;
						obg.position.y += 0.3;
						obg.rotation.y += 0.05;
						i++;
						// console.log(i);
					}
				} else if(animeState == 2){ // 2e étape animation (refermer le coffre et ranger le gemme)
					if(i >= 100){ // permet de faire tourner x fois le gemme jusqu'à l'arrêt
						animeState = 0;
						i = 0;
					} else {
						obc.rotation.x -= 0.03;
						obg.position.y -= 0.3;
						obg.rotation.y += 0.05;
						i++;
						// console.log(i);
					}
				};
			}

			// ============== WINDOW REZISE ==============
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// ============== GUI ==============
			function buildGui() {
				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Intensite: pointLight.intensity,
					Volume: soundVolume
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	intensiter = val;
        });

				gui.add( params, 'Volume', 0, 100).onChange( function( val ) {
        	// soundVolume = val;
					listener.setMasterVolume( val );
        });

				gui.open(); // Ajout du gui à la scene
			}

			// ============== CONTROLS ==============
			function control( deltaTime ) {
				const speedDelta = deltaTime * ( playerOnFloor ? 350 : 90 );
				// console.log(keyStates);
				if(playerTouchBuffer == undefined && gameState == 1){
					if ( keyStates[ 'KeyW' ] ) {
						if(playerOnFloor){
							actionAnime = 'walk';
						}
						playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
					}
					if ( keyStates[ 'KeyS' ] ) {
						if(playerOnFloor){
							actionAnime = 'back';
						}
						playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
					}
					if ( keyStates[ 'KeyA' ] ) {
						if(playerOnFloor){
							actionAnime = 'right';
						}
						playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
					}
					if ( keyStates[ 'KeyD' ] ) {
						if(playerOnFloor){
							actionAnime = 'left';
						}
						playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
					}
					if ( keyStates[ 'KeyK' ] ) {
						console.log("x: "+player.position.x);
						console.log("z: "+player.position.z);
					}
					if ( playerOnFloor ) {
						if ( keyStates[ 'Space' ] ) {
							actionAnime = 'jump';
							playerVelocity.y = 70;
						} else if( !keyStates[ 'KeyA' ] && !keyStates[ 'KeyW' ] && !keyStates[ 'KeyS' ] && !keyStates[ 'KeyD' ]){
							actionAnime = 'stand';
						}
					} if ( keyStates[ 'KeyQ' ] ) {
						player.rotation.y += 0.03;
					}
					if ( keyStates[ 'KeyE' ] ) {
						player.rotation.y -= 0.03;
					}
				}
			}

			// ============== MOVEMEMENTS ==============
			function getForwardVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();

				return playerDirection;
			}

			function getSideVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( player.up );

				return playerDirection;
			}

			function playerCollisions() {
				const result = worldOctree.capsuleIntersect( playerCollider );
				playerOnFloor = false;
				if ( result ) {
					playerOnFloor = result.normal.y >= 0;
					if ( ! playerOnFloor ) {
						playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
					}
					playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
				}

			}

			function updatePlayer( deltaTime ) {
				let damping = Math.exp( - 4 * deltaTime ) - 1;
				if ( ! playerOnFloor ) {
					playerVelocity.y -= GRAVITY * deltaTime;
					damping *= 0.1;
				}
				playerVelocity.addScaledVector( playerVelocity, damping );
				const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
				playerCollider.translate( deltaPosition );
				playerCollisions();
				player.position.copy( playerCollider.end );
				// updateSocket(player);
			}

			function teleportPlayerIfOob(){
				if (player.position.y <= -150){
					playerCollider.start.set( 0, -24.5, 0 );
					playerCollider.end.set( 0, -25, 0 );
					playerCollider.radius =  1.35;
					player.position.copy( playerCollider.end );
				}
			}

			function animeChange( anime ){
				const nbr = actionDicoNbr[anime];
				// console.log(nbr+": "+anime);
				mixer = new THREE.AnimationMixer( player2 );
				const action = mixer.clipAction( actionArray[nbr] );
				action.play();
			}

			// ============== BALLES ==============
			function throwBall() { // tire
				const sphere = spheres[ 0 ];
				player.getWorldDirection( playerDirection );
				sphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );
				const impulse = 650 + 30;
				sphere.velocity.copy( playerDirection ).multiplyScalar( impulse );
				sphere.velocity.addScaledVector( playerVelocity, 2 );
				console.log('shot');
				audioLoad.load('shoot.mp3', function(data){
					soundaa.setBuffer( data );
					soundaa.setVolume( soundVolume - 10 );
					soundaa.play();
				});
				socket.emit('ballShoot', {data: spheres[0].velocity, id: playerId});
			}

			function spheresCollisions() {
				for ( let i = 0, length = spheres.length; i < length; i ++ ) {
					const s1 = spheres[ i ];
					const d3 = s1.collider.center.distanceToSquared( player2.position );
					if(d3 < 90){
						socket.emit('touchPlayer', playerId);
					}
				}
			}

			function updateSpheres( deltaTime ) {
				spheres.forEach( sphere => {
					sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );
					const result = worldOctree.sphereIntersect( sphere.collider );
					if ( result ) {
						sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
						sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );
					} else {
						sphere.velocity.y -= GRAVITY * deltaTime;
					}
					// const damping = Math.exp( - 1.5 * deltaTime ) - 1;
					// sphere.velocity.addScaledVector( sphere.velocity, damping );
					// playerSphereCollision( sphere );
				} );
				spheresCollisions();
				for ( const sphere of spheres ) {
					sphere.mesh.position.copy( sphere.collider.center );
				}
			}

			// ============== FONCTION MULTIJOUEURS ==============
			function remoteData(){
				if(dataArray.length > 0){
					for(let data of dataArray){
						if(playerId != data.id){
							player2.position.set(data.x, data.y, data.z );
							player2.rotation.y = data.h;
							if(data.action != actionAnimeBuffer){
								actionAnimeBuffer = data.action;
								animeChange( data.action );
							}
						}
					}
				}
			}

			function updateSocket(object){
				// if (this.socket !== undefined){
					//console.log(`PlayerLocal.updateSocket - rotation(${this.object.rotation.x.toFixed(1)},${this.object.rotation.y.toFixed(1)},${this.object.rotation.z.toFixed(1)})`);
					socket.emit('update', {
						x: object.position.x,
						y: object.position.y+17,
						z: object.position.z,
						h: object.rotation.y,
						action: actionAnime
					});
			}

			// ============== DEBUT DE PARTIE ==============
			function sendStartRequest(){
				socket.emit('startRequest');
			}

			function startGame(){
				if(!gameState){
					gameState = 1;
					const overlay = document.getElementById( 'overlay' );
					overlay.remove();
					loadSound();
				}
			}

			// ============== FIN DE PARTIE ==============
			function endGame(data){
				animeState = 1;
				document.getElementById('message').hidden = false;
				if(data === playerId && gameState ){
					console.log("win");
					displayMessage("YOU WIN");
				} else {
					console.log("lose");
					displayMessage("YOU LOSE");
				}
				gameState = 2;
			}

			// ============== LUMIERE ==============
			function updateLight(deltaTime){
				pointLight.intensity = 5+deltaTime*150+intensiter;
				pointLight.penumbra = 6+deltaTime*200;
				pointLight.distance = 300;
			}

			// ============== DISPLAY MESSAGE ==============
			function displayMessage(msg){
				const element = document.getElementById('message');
				element.innerHTML = msg;
			}

			function animate() {
				// ========= LOCAL PART =========
				if( obc && obg && cave && !gameState && actionArray.length === actions.length ){
					document.getElementById('startButton').hidden = false;
				}

				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;
				window.requestAnimationFrame( animate ); // animation de la page
				stats.update();
				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
					control( deltaTime );
					updatePlayer( deltaTime );
					updateSocket( player );
					updateLight( deltaTime );
					updateSpheres( deltaTime );
					teleportPlayerIfOob();
				}

				const delta = clock.getDelta();
				if ( mixer ){
					mixer.timeScale = 20;
					mixer.update( delta );
				}

				if(player && obg){
					animeChest();
					if(Math.abs(player.position.x - obg.position.x) < 70 && Math.abs(player.position.z - obg.position.z) < 70 ){
						if(!animeState){
							socket.emit('playerWin',playerId);

						}
					}
				}

				renderer.render( scene, camera );


				// ========= MULTIPLAYER PART =========

				socket.on('setId', function(data){
					playerId = data.id;
				});

				socket.on('remoteData', function(data){
					dataArray = data;
					if(gameState){
						remoteData();
					}
				});


				socket.on('touchPlayerReponse', function(data){
					if(playerTouchBuffer == undefined && data != playerId){
						playerTouchBuffer = parseInt(clock["oldTime"]);
						actionAnime = "fall";
						console.log('toucher !');
						document.getElementById('message').hidden = false;
						audioLoad.load('crie.mp3', function(data){
							soundaa.setBuffer( data );
							soundaa.setVolume( soundVolume );
							soundaa.play();
						});
					}
				});

				if(parseInt(clock["oldTime"]) - playerTouchBuffer >= 5000 && playerTouchBuffer){
					playerTouchBuffer = undefined;
					document.getElementById('message').hidden = true;
				} else if(playerTouchBuffer){
					const value = parseInt( (6000 - (parseInt(clock["oldTime"]) - playerTouchBuffer)) / 1000);
					displayMessage(value);
					console.log(value);
				}

				socket.on('end', function(data){
					if(gameState){
						endGame(data);
					}
				});

				socket.on('startGameApprouved', function(){
					// console.log('start request approuved');
					startClockBuffer = parseInt(clock["oldTime"]);
				});

				if( startClockBuffer ){
					const countdown = document.getElementById('countdown');
					const value = parseInt( (4000 - (parseInt(clock["oldTime"]) - startClockBuffer)) / 1000);
					countdown.innerHTML = value;
				}
				if( parseInt(clock["oldTime"]) - startClockBuffer > 3000 && startClockBuffer){
					startGame();
					startClockBuffer = undefined;
				}
			}
		</script>
	</body>
</html>
