<!DOCTYPE html>
<html lang="en">
	<head>
		<head>
			<title>Trésor</title>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
			<link type="text/css" rel="stylesheet" href="main.css">
			<script src="/socket.io/socket.io.js"></script>
		</head>
	</head>
	<body>
		<!-- <script src="https://code.jquery.com/jquery-1.11.1.js"></script> -->
		<script type="module">
			// ============== IMPORTS ==============
			import * as THREE from './build/three.module.js'; // Element threejs
			import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page

			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OBJLoader } from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import { MTLLoader } from './jsm/loaders/MTLLoader.js'; // ² obj .mtl (pour texture)
			import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // FBX looader
			import { Capsule } from './jsm/math/Capsule.js';
			import { Octree } from './jsm/math/Octree.js';

			// ============== VARIABLES ===============
			let stats,gui,controls;
			let camera, scene, renderer;
			let player, player2, playerId,playerShoot, playerShootBuffer, playerTouch, playerTouchBuffer;
			let objChampi;
			let pointLight, pointLight2, spotLightHelper;
			let playerOnFloor = false;
			let sphereIdx = 0;
			let player2Ball;
			let mixer, actionAnime;

			// ============== CONSTANTES ==============
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
			const clock = new THREE.Clock();
			const socket = io.connect("localhost:2600");
			const worldOctree = new Octree();
			const spheres = [];
			const vector1 = new THREE.Vector3();
			const vector2 = new THREE.Vector3();
			const vector3 = new THREE.Vector3();

			// ============== DEFINITION ==============
			const actionDico = {
				walk: 0,
				jump: 1,
			}

			// ============== TABLEAUX ===============
			const keyStates = {};
			let dataArray = [];
			let playerArray = new Array();

			// ============== PARAMETRES ===============
			const STEPS_PER_FRAME = 5;
			const GRAVITY = 30;
			const NUM_SPHERES = 2;
			const SPHERE_RADIUS = 4;

			// =============== EVENT LISTENER ===============
			document.addEventListener( 'keydown', ( event ) => {
				keyStates[ event.code ] = true;
			} );

			document.addEventListener( 'keyup', ( event ) => {
				keyStates[ event.code ] = false;
			} );

			document.addEventListener( 'mouseup', () => {
				throwBall();
			} );

			document.addEventListener( 'mousedown', () => {
				document.body.requestPointerLock();
			} );

			document.body.addEventListener( 'mousemove', ( event ) => {
				if ( document.pointerLockElement === document.body ) {
					player.rotation.y -= event.movementX / 500;
					player.rotation.x += event.movementY / 500 ;
				}
			});

			// ============== APPEL FONCTIONS ==============
			init();
			buildGui();
			animate();


			// ============== FONCTIONS ==============
			function init() {

				// ============= SCENE =============
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x6e7bbb );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true; // ombre activer
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // type d'encoding pour les ombres
				document.body.appendChild( renderer.domElement );


				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 1 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				pointLight = new THREE.PointLight(0xffffff, 0.5); // (couleur, intensite)
				pointLight.position.set(0, 100, 0); // position (x, z, y)
				pointLight.castShadow = true; // renvoie des ombres


				pointLight2 = new THREE.PointLight(0xffffff, 0.8); // (couleur, intensite)
				pointLight2.position.set(0, 100, 0); // position (x, z, y)
				pointLight2.castShadow = true; // renvoie des ombres


				const sphereGeometry = new THREE.SphereGeometry( SPHERE_RADIUS, 32, 32 );
				const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0x888855, roughness: 0.8, metalness: 0.5 } );
				for ( let i = 0; i < NUM_SPHERES; i ++ ) {
					const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					sphere.castShadow = true;
					sphere.receiveShadow = true;
					sphere.position.set( 0, 0, 0 );
					scene.add( sphere );
					spheres.push( { mesh: sphere, collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ), velocity: new THREE.Vector3() } );
				}

				const loaderGLB = new GLTFLoader().setPath( 'models/' );
				loaderGLB.load( 'labyCave.gltf', function ( obj ) {
					obj.scene.position.y = -20;
					obj.scene.rotation.z = 6.28;
					obj.scene.scale.multiplyScalar(-1);
					// scene.add( obj.scene );
					// worldOctree.fromGraphNode( obj.scene );
				});
				const sol = new THREE.Mesh(
						new THREE.BoxGeometry( 8000, 5, 8000 ),
						new THREE.MeshPhongMaterial( { color: 0x363b5c, transparent: true, opacity: 0.8  } )
				);
				sol.receiveShadow = true;
				sol.position.set(3500, -50, 3500);
				scene.add( sol );
				worldOctree.fromGraphNode( sol );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
				camera.rotation.order = 'YXZ';
				camera.position.y = 15;
				camera.position.z = 2;
				camera.rotation.y = 3.25;


				// ===== CREATION PERSONNAGE =====
				const loaderFBX = new FBXLoader().setPath( 'models/' );

				player = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0 } )
				);
				player.add(camera);
				player.rotation.order = 'YXZ';
				loaderFBX.load( 'champi.fbx', function ( obj ) {
					obj.traverse( function ( child ) {
						if( child.isMesh ){
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					obj.position.y = camera.position.y - 17;
					player.add( obj );
					player.add(pointLight);
				});
				scene.add(player);

				player2 = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 40, 1 ),
					new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0 } )
				);

				loaderFBX.load( 'champiAnimate.fbx', function( obj ) {
					obj.traverse( function( child ) {
						if( child.isMesh ){
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					// mixer = new THREE.AnimationMixer( obj );
					// const action = mixer.clipAction( obj.animations[ 1 ] );
					// action.play();
					obj.position.y = player2.position.y - 20;
					obj.add(pointLight2);
					player2.add( obj );
					// player2 = obj;
				});

				scene.add(player2);

				console.log(player.position);
				console.log(camera.position);
				// player.position.y = camera.position.y - 40;
				// player.position.x = camera.position.x - 80;

				// player2 = playerArray[1];

				// scene.add(player2);


				socket.emit('init', {
					x: player.position.x,
					y: player.position.y+17,
					z: player.position.z,
					h: player.rotation.y,
					// b: spheres[0].velocity,
					// bx: spheres[0].velocity.x,
					// by: spheres[0].velocity.y,
					// bz: spheres[0].velocity.z
					// pb: this.object.rotation.x
					action: actionAnime
				});

				// ============ EVENT LISTENER ============
				window.addEventListener( 'resize', onWindowResize );
			}

			// ================= FONCTIONS UTILES =================
			// ============== WINDOW REZISE ==============
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// ============== GUI ==============
			function buildGui() {
				gui = new GUI(); // création gui

				// ========= SETTINGS LIST =========
				const params = { // liste des parametres
					Helper: false, // case à cocher => renvoie true OU false
					Freecam: false,
					Intensite: pointLight.intensity,
        	Background: scene.background.getHex(), //getHex() => recup la couleur en hexa
					"Ajouter personnage": function(){ createPerso(); }
				};

				// ========= SETTINGS ACTIONS =========
				gui.add( params, 'Helper', true, false ).onChange( function( val ) {
					spotLightHelper.visible = val; // defini la visibilite des helpers sur true OU false
					shadowCameraHelper.visible = val;
				});

				gui.add( params, 'Freecam', true, false ).onChange( function( val ) { // permet de désactiver les limites de la camera
					if(val){ // si val == true (donc cocher)
						controls.minDistance = 0;
						controls.maxDistance = 99999999;
						controls.maxPolarAngle = 360;
					} else { // si decocher
						controls.minDistance = 150;
						controls.maxDistance = 300;
						controls.maxPolarAngle = Math.PI / 2.3;
					}
				});

				gui.add( params, 'Intensite', 0, 10).onChange( function( val ) {
        	pointLight.intensity = val;
        });

				gui.addColor( params, 'Background' ).onChange( function ( val ) {
        	scene.background = new THREE.Color( val );
        });

				gui.add( params, "Ajouter personnage");

				gui.open(); // Ajout du gui à la scene
			}

			// ============== CONTROLS ==============
			function control( deltaTime ) {
				const speedDelta = deltaTime * ( playerOnFloor ? 350 : 90 );
				// console.log(keyStates);
				if(playerTouchBuffer == undefined){
					if ( keyStates[ 'KeyW' ] ) {
						if(playerOnFloor){
							actionAnime = 'walk';
						}
						playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
					}

					if ( keyStates[ 'KeyS' ] ) {
						playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
					}

					if ( keyStates[ 'KeyA' ] ) {
						playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
					}

					if ( keyStates[ 'KeyD' ] ) {
						playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
					}

					if ( playerOnFloor ) {
						if ( keyStates[ 'Space' ] ) {
							actionAnime = 'jump';
							playerVelocity.y = 70;
						}
					}
					if ( keyStates[ 'KeyQ' ] ) {
						player.rotation.y += 0.03;
					}
					if ( keyStates[ 'KeyE' ] ) {
						player.rotation.y -= 0.03;
					}
				}
			}

			// ============== MOVEMEMENTS ==============
			function getForwardVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();

				return playerDirection;
			}

			function getSideVector() {
				player.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( player.up );

				return playerDirection;
			}

			function playerCollisions() {
				const result = worldOctree.capsuleIntersect( playerCollider );
				playerOnFloor = false;
				if ( result ) {
					playerOnFloor = result.normal.y >= 0;
					if ( ! playerOnFloor ) {
						playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
					}
					playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
				}

			}

			function updatePlayer( deltaTime ) {
				let damping = Math.exp( - 4 * deltaTime ) - 1;
				if ( ! playerOnFloor ) {
					playerVelocity.y -= GRAVITY * deltaTime;
					damping *= 0.1;
				}
				playerVelocity.addScaledVector( playerVelocity, damping );
				const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
				playerCollider.translate( deltaPosition );
				playerCollisions();
				player.position.copy( playerCollider.end );
				// updateSocket(player);
			}

			function teleportPlayerIfOob(){
				if (player.position.y <= -150){
					playerCollider.start.set( 0, -24.5, 0 );
					playerCollider.end.set( 0, -25, 0 );
					playerCollider.radius =  1.35;
					player.position.copy( playerCollider.end );
				}
			}

			// ============== BALLES ==============
			function throwBall() {
				const sphere = spheres[ 0 ];
				player.getWorldDirection( playerDirection );
				sphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );
				const impulse = 650 + 30;
				sphere.velocity.copy( playerDirection ).multiplyScalar( impulse );
				sphere.velocity.addScaledVector( playerVelocity, 2 );
				console.log('shot');
				socket.emit('ballShoot', {data: spheres[0].velocity, id: playerId});
			}

			function spheresCollisions() {
				for ( let i = 0, length = spheres.length; i < length; i ++ ) {
					const s1 = spheres[ i ];
					const d3 = s1.collider.center.distanceToSquared( player2.position );
					if(d3 < 70){
						socket.emit('touchPlayer', playerId);
					}
				}
			}

			function updateSpheres( deltaTime ) {
				spheres.forEach( sphere => {
					sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );
					const result = worldOctree.sphereIntersect( sphere.collider );
					if ( result ) {
						sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
						sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );
					} else {
						sphere.velocity.y -= GRAVITY * deltaTime;
					}
					// const damping = Math.exp( - 1.5 * deltaTime ) - 1;
					// sphere.velocity.addScaledVector( sphere.velocity, damping );
					// playerSphereCollision( sphere );
				} );
				spheresCollisions();
				for ( const sphere of spheres ) {
					sphere.mesh.position.copy( sphere.collider.center );
				}
			}


			// ============== FONCTION MULTIJOUEURS ==============
			function remoteData(){
				// console.log("remote !");
				if(dataArray.length > 0){
					for(let data of dataArray){
						if(playerId != data.id){
							player2.position.set(data.x, data.y, data.z );
							player2.rotation.y = data.h;
							if(data.action != actionAnime){
								actionAnime = data.action;
								// mixer = new THREE.AnimationMixer( player2 );
								// console.log( actionAnime );
								// console.log( actionDico[data.action] );
								// const action = mixer.clipAction( player2.animations[ actionDico[data.action] ] );
								// action.play();
							}
						}
					}
				}
			}

			function updateSocket(object){
				// if (this.socket !== undefined){
					//console.log(`PlayerLocal.updateSocket - rotation(${this.object.rotation.x.toFixed(1)},${this.object.rotation.y.toFixed(1)},${this.object.rotation.z.toFixed(1)})`);
					socket.emit('update', {
						x: object.position.x,
						y: object.position.y+17,
						z: object.position.z,
						h: object.rotation.y,
						// b: spheres[0].velocity,
						// bx: spheres[0].velocity.x,
						// by: spheres[0].velocity.y,
						// bz: spheres[0].velocity.z
						// pb: this.object.rotation.x,
						action: actionAnime
					})
			}

			function animate() {
				// ========= LOCAL PART =========
				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;
				window.requestAnimationFrame( animate ); // animation de la page
				stats.update();
				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
					control( deltaTime );
					updatePlayer( deltaTime );
					updateSocket( player );
					// updateLight();
					updateSpheres( deltaTime );
					teleportPlayerIfOob();
				}

				// const delta = clock.getDelta();
				// if ( mixer ){
				// 	// for(y = 0; y < mixerArray.length; y++){
				// 		// mixer = mixerArray[y];
				// 		mixer.timeScale = 7;
				// 		mixer.update( delta );
				// 	// }
				// }

				renderer.render( scene, camera );


				// ========= MULTIPLAYER PART =========
				socket.on('setId', function(data){
					playerId = data.id;
					// console.log( data.id );
				});
				socket.on('remoteData', function(data){
					dataArray = data;
					remoteData();
				});

				socket.on('touchPlayerReponse', function(data){
					// playerTouch = true;
					if(playerTouchBuffer == undefined && data != playerId){
						playerTouchBuffer = parseInt(clock["oldTime"]);
						console.log('toucher !');
					}
				});

				if(parseInt(clock["oldTime"]) - playerTouchBuffer >= 5000 && playerTouchBuffer){
					// playerTouch = false;
					playerTouchBuffer = undefined;
				}

				socket.on('ballShoot', function(data){
					spheres[1].velocity.copy(data);
					// console.log(spheres[1].velocity);
				});


				// console.log(spheres[0].position);




				// socket.on('userData', function(userData){
				// 	// console.log(userData.x);
				// 	// player.position.set(userData.x, userData.y,userData.z);
				// });

			}
		</script>
	</body>
</html>
