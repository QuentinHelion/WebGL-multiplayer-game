<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Trésor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">

			// ============== IMPORTS ==============
			import * as THREE from '../build/three.module.js'; // Element threejs
			// import { OrbitControls } from './jsm/controls/OrbitControls.js'; // Controle de la caméra
			import { FirstPersonControls } from './jsm/controls/FirstPersonControls.js';
			import { GUI } from './jsm/libs/dat.gui.module.js'; // Ajout d'un GUI
			import Stats from './jsm/libs/stats.module.js'; // Affichage des stats de la page
			import {OBJLoader} from './jsm/loaders/OBJLoader.js'; // ajout d'obj
			import {MTLLoader} from './jsm/loaders/MTLLoader.js'; // obj .mtl (pour texture)
			 import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			// ============== VARIABLES ===============
			let stats,mixer;
			let camera, scene, renderer;
			let mA,mB;
			let gui,obje,objee;
			let spotLight, lightHelper, shadowCameraHelper;
			let controls;
			let object;
			const clock = new THREE.Clock();

			// ============== APPEL FONCTIONS ==============
			init();
			animate();
			// buildGui();

			// ============== FONCTIONS ==============
			function init() {

				scene = new THREE.Scene();
				// scene.background = new THREE.Color( 0x000000 );

				// ============= AFFICHAGE STATS =============
				stats = new Stats(); // création stats
				document.body.appendChild( stats.dom ); // ajout des stats a la scene


				// ============= LIGHT =============
				// ===== AMBIANTE ======
				const ambient = new THREE.AmbientLight( 0xffffff , 0.1 ); // (couleur, intensite)
				scene.add( ambient );

				// ===== LIGHT POINT =====
				const pointLight = new THREE.PointLight(0xffffff, 0.2); // (couleur, intensite)
				pointLight.position.set(0, 300, 0); // position (x, z, y)
				scene.add(pointLight);

				// ===== SPOT LIGHT =====
				spotLight = new THREE.SpotLight( 0xFFFFFF, 0.2); // (couleur, intensite)
				spotLight.position.set( 0, 300, 0 ); // position
				spotLight.angle = Math.PI / 6; // angle d'ouverture
				spotLight.decay = 1.5; // diminution avec la distance
				spotLight.distance = 300; // distance
				scene.add( spotLight );



				// ============== TEXTURES ==============
				// ===== LOADERS =====
				const loader = new THREE.TextureLoader();
				loader.setPath( './textures/' ); // emplacement des textures

				const loaderMTL = new MTLLoader(); // mtl => fichier qui contient les textures d'un objet 3d
				loaderMTL.setPath( './models/' ); // emplacement des fichiers




				// ===== CAVE =====
				// loaderMTL.load('cave.mtl', (mtl) => { // new texture d'obj
				// 	mtl.preload(); // charge le fichier texture
				// 	const caveOBJ = new OBJLoader(); // new obj
				// 	caveOBJ.setMaterials(mtl); // ajout les texture a l'obj
				// 	caveOBJ.load('./models/cave.obj', (obj) => { // charge l'objet
				// 		obj.position.set(0,60,0); // x, z, y
				// 		obj.receiveShadow = true; // prend les ombres
				// 		scene.add(obj); // ajout de l'obj à la scène
				// 	});
				// });




				const loaderr = new FBXLoader();
				                loaderr.load( './models/champi.fbx', function ( object ) {

				                    mixer = new THREE.AnimationMixer( object );

				                    const action = mixer.clipAction( object.animations[ 0 ] );
				                    action.play();
														object.rotation.y += 600;
														object.position.x = camera.position.x;
														object.position.y  = camera.position.y -20;
														object.position.z = camera.position.z -90 ;
														// camera.position.x = object.position.x;
													  // camera.position.y = object.position.y + 80;
														// camera.position.z = object.position.z;

				                    object.traverse( function ( child ) {

				                        if ( child.isMesh ) {

				                            child.castShadow = true;
				                            child.receiveShadow = true;





				                        }

				                    } );

				                    camera.add( object );
						    scene.add(camera);

				                } );


				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 3, 10, 10 ); // position
				dirLight.castShadow = true;// envoie des ombres
				dirLight.shadow.camera.top = 2;
				dirLight.shadow.camera.bottom = - 2;
				dirLight.shadow.camera.left = - 2;
				dirLight.shadow.camera.right = 2;
				dirLight.shadow.camera.near = 0.1;//Frustum de la caméra près du plan.
				dirLight.shadow.camera.far = 40;//Plan éloigné du tronc de la caméra.
				scene.add( dirLight );// ajout dans la scene


				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );//lumière au-dessus de la scène, avec une décoloration passant de la couleur du ciel à la couleur du sol.
				hemiLight.position.set( 0, 20, 0 );// Cette lumière ne peut pas être utilisée pour projeter des ombres.
				scene.add( hemiLight );

				const meshh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				// depthWrite: calcule toujours la profondeur, mais rend l'objet entier indépendamment
				meshh.rotation.x = - Math.PI / 2;
				meshh.receiveShadow = true; // recois les ombres
				scene.add( meshh );// ajout dans la scene

				// ============== RENDER ==============
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );


				// ============= CAMERA =============
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );


				const GeneratorControls = function () {

														this.frequency = oscillator.frequency.value;
														this.wavetype = oscillator.type;

												};

												controls = new FirstPersonControls( camera, renderer.domElement );

												controls.movementSpeed = 250;
												controls.lookSpeed = 0.19;
												controls.noFly = true;
												controls.lookVertical = true;


				window.addEventListener( 'resize', onWindowResize );
			}




			// ============== GUI ==============


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );


				const delta = clock.getDelta();

				controls.update( delta );

				if ( mixer ){
					mixer.update( delta );
				}

				if ( object ){
					object.position.x = camera.position.x;
					object.position.y  = camera.position.y ;
					object.position.z = camera.position.z ;
				}

				renderer.render( scene, camera );
				stats.update();
			}

    </script>
  </body>
</html>
